// Generated by CoffeeScript 1.6.3
(function() {
  'use strict';
  var addDot, addTone, audio, canvas, chordChangeTimeout, chordIndex, clamp, config, dotAddRemoveTimeout, dots, drawingCanvas, fadeRect, lastMouse, maxDotCount, noteTriggerTimeout, notes, onMouseMove, onResize, onTick, scale, setChord, stage, tickTones, wrapToStage;

  notes = ["e", "f", "f#", "g", "g#", "a", "a#", "b", "c", "c#", "d", "d#", "e", "f", "f#", "g", "g#", "a", "a#", "b", "c", "c#", "d", "d#", "e", "f", "f#", "g", "g#", "a", "a#", "b", "c", "c#", "d", "d#", "e"];

  audio = {
    actives: [],
    pool: []
  };

  config = {
    maxDotFactor: 60 / 500000,
    maxMouseDistance: 100,
    maxContactDistance: 50,
    contactTimeout: 400,
    contactVelocityFactor: 0.5,
    dotSpeedThreshold: 10,
    dotDeceleration: 0.99,
    fadeFactor: 0.05,
    chordChangeTimeout: 5000,
    dotAddRemoveTimeout: 100,
    noteTriggerTimeout: 50,
    chordList: ["e, c, g", "e, b, g"]
  };

  maxDotCount = 1;

  dots = [];

  lastMouse = {
    x: 0,
    y: 0
  };

  chordChangeTimeout = 0;

  dotAddRemoveTimeout = 0;

  noteTriggerTimeout = 0;

  chordIndex = 0;

  scale = [];

  fadeRect = canvas = stage = drawingCanvas = null;

  this.init = function() {
    canvas = document.getElementById("mainCanvas");
    stage = new createjs.Stage(canvas);
    stage.autoClear = false;
    stage.enableDOMEvents(true);
    createjs.Touch.enable(stage);
    createjs.Ticker.timingMode = createjs.Ticker.RAF_SYNCHED;
    createjs.Ticker.setFPS(60);
    canvas.setAttribute("style", "background-color: #000000");
    drawingCanvas = new createjs.Shape();
    stage.addChild(drawingCanvas);
    fadeRect = new createjs.Shape();
    stage.addChild(fadeRect);
    setChord(chordIndex);
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    if (window.AudioContext == null) {
      console.log("audio api not available!");
    } else {
      audio.ctx = new AudioContext();
    }
    window.addEventListener('resize', onResize);
    onResize();
    stage.addEventListener("stagemousemove", onMouseMove);
    return createjs.Ticker.addEventListener("tick", onTick);
  };

  onResize = function() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    fadeRect.graphics.clear().beginFill("rgba(0,0,0," + config.fadeFactor + ")").rect(0, 0, canvas.width, canvas.height);
    maxDotCount = Math.round(config.maxDotFactor * canvas.width * canvas.height);
    return console.log("maxDotCount: " + maxDotCount);
  };

  onTick = function(event) {
    var avgVelocity, avgXPos, avgXVel, avgYPos, avgYVel, dMouseX, dMouseY, dX, dY, dist, distMouse, dot, dx, dy, g, indScale, note, otherDot, pan, speed, vf, volume, wasNotePlayed, _i, _j, _len, _len1;
    tickTones(event.delta);
    chordChangeTimeout -= event.delta;
    dotAddRemoveTimeout -= event.delta;
    noteTriggerTimeout -= event.delta;
    dMouseX = stage.mouseX - lastMouse.x;
    dMouseY = stage.mouseY - lastMouse.y;
    if (dotAddRemoveTimeout < 0) {
      dotAddRemoveTimeout = config.dotAddRemoveTimeout;
      if (dots.length < maxDotCount) {
        addDot();
        console.log("adding... " + dots.length);
      } else if (dots.length > maxDotCount) {
        dots.pop();
        console.log("removing... " + dots.length);
      }
    }
    g = drawingCanvas.graphics;
    g.clear().setStrokeStyle(1).beginStroke('#ffffff');
    wasNotePlayed = false;
    for (_i = 0, _len = dots.length; _i < _len; _i++) {
      dot = dots[_i];
      drawingCanvas.graphics.moveTo(dot.x, dot.y);
      dot.x += dot.velocity.x;
      dot.y += dot.velocity.y;
      drawingCanvas.graphics.lineTo(dot.x, dot.y);
      wrapToStage(dot);
      dot.contactTimeout -= event.delta;
      for (_j = 0, _len1 = dots.length; _j < _len1; _j++) {
        otherDot = dots[_j];
        if (!(otherDot !== dot)) {
          continue;
        }
        dx = dot.x - otherDot.x;
        dy = dot.y - otherDot.y;
        dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < config.maxContactDistance) {
          if (dist > 0) {
            vf = config.contactVelocityFactor;
            dot.velocity.x += vf * dx / dist;
            dot.velocity.y += vf * dy / dist;
            otherDot.velocity.x -= vf * dx / dist;
            otherDot.velocity.y -= vf * dy / dist;
          }
          if (dot.contactTimeout < 0) {
            dot.contactTimeout = config.contactTimeout;
            g.moveTo(dot.x, dot.y).lineTo(otherDot.x, otherDot.y);
            if (!wasNotePlayed && noteTriggerTimeout < 0) {
              wasNotePlayed = true;
              noteTriggerTimeout = config.noteTriggerTimeout;
              avgYPos = (dot.y + otherDot.y) / 2;
              indScale = Math.round(Math.random() * 2) * 2 - 1 + scale.length - 1 - Math.round(scale.length * avgYPos / canvas.height);
              indScale = clamp(indScale, 0, scale.length - 1);
              avgXPos = (dot.x + otherDot.x) / 2;
              pan = avgXPos / (canvas.width * 0.5) - 1;
              avgXVel = (Math.abs(dot.velocity.x) + Math.abs(otherDot.velocity.x)) / 2;
              avgYVel = (Math.abs(dot.velocity.y) + Math.abs(otherDot.velocity.y)) / 2;
              avgVelocity = Math.sqrt(avgXVel * avgXVel + avgYVel * avgYVel);
              avgVelocity = clamp(avgVelocity, 0, config.dotSpeedThreshold);
              volume = 0.2 + 0.8 * (avgVelocity / config.dotSpeedThreshold);
              note = scale[indScale];
              addTone(note, pan, volume);
            }
          }
        }
      }
      dX = dot.x - stage.mouseX;
      dY = dot.y - stage.mouseY;
      distMouse = Math.sqrt(dX * dX + dY * dY);
      if (distMouse < config.maxMouseDistance) {
        dot.velocity.x += 0.001 * (config.maxMouseDistance - distMouse) * dMouseX;
        dot.velocity.y += 0.001 * (config.maxMouseDistance - distMouse) * dMouseY;
      }
      speed = Math.sqrt(dot.velocity.x * dot.velocity.x + dot.velocity.y * dot.velocity.y);
      if (speed > config.dotSpeedThreshold) {
        dot.velocity.x = config.dotSpeedThreshold * dot.velocity.x / speed;
        dot.velocity.y = config.dotSpeedThreshold * dot.velocity.y / speed;
      }
      dot.velocity.x *= config.dotDeceleration;
      dot.velocity.y *= config.dotDeceleration;
    }
    lastMouse.x = stage.mouseX;
    lastMouse.y = stage.mouseY;
    return stage.update();
  };

  tickTones = function(delta) {
    var frac, toDequeue, tone, _i, _len, _ref, _results;
    toDequeue = 0;
    _ref = audio.actives;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      tone = _ref[_i];
      tone.duration -= delta;
      if (tone.duration < 0) {
        tone.osc.stop(0);
        toDequeue++;
      } else {
        frac = (tone.duration / tone.initDuration) * tone.volume;
        tone.gain.gain.value = frac * frac;
      }
    }
    _results = [];
    while (toDequeue > 0) {
      audio.actives.shift();
      _results.push(toDequeue--);
    }
    return _results;
  };

  addTone = function(note, pan, volume) {
    var gain, osc, tone;
    if (audio.actives.length > 8) {
      return;
    }
    tone = null;
    if (tone == null) {
      osc = audio.ctx.createOscillator();
      osc.type = "sine";
      gain = audio.ctx.createGain();
      osc.connect(gain);
      gain.connect(audio.ctx.destination);
      tone = {
        osc: osc,
        gain: gain
      };
    }
    tone.duration = 1000;
    tone.initDuration = tone.duration;
    tone.volume = volume;
    tone.gain.gain.value = tone.volume;
    tone.osc.frequency.value = 440 * Math.pow(2, (note / 12) - 1);
    tone.osc.start(0);
    return audio.actives.push(tone);
  };

  onMouseMove = function(event) {
    if (chordChangeTimeout < 0) {
      chordIndex = (chordIndex + 1) % config.chordList.length;
      setChord(chordIndex);
    }
    return chordChangeTimeout = config.chordChangeTimeout;
  };

  setChord = function(index) {
    var chordNotes, i, note, _i, _len, _results;
    chordNotes = config.chordList[index];
    scale = [];
    _results = [];
    for (i = _i = 0, _len = notes.length; _i < _len; i = ++_i) {
      note = notes[i];
      if (chordNotes.indexOf(note) !== -1) {
        _results.push(scale.push(i));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  addDot = function() {
    var dot;
    dot = new createjs.Point(Math.random() * canvas.width, Math.random() * canvas.height);
    dot.velocity = new createjs.Point(0, 0);
    dot.contactTimeout = config.contactTimeout;
    return dots.push(dot);
  };

  wrapToStage = function(dot) {
    if (dot.x < 0) {
      dot.x += canvas.width;
    } else if (dot.x > canvas.width) {
      dot.x -= canvas.width;
    }
    if (dot.y < 0) {
      return dot.y += canvas.height;
    } else if (dot.y > canvas.height) {
      return dot.y -= canvas.height;
    }
  };

  clamp = function(val, min, max) {
    return Math.max(min, Math.min(max, val));
  };

}).call(this);
